// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SPRITE_DUNG_SPRITE_H_
#define FLATBUFFERS_GENERATED_SPRITE_DUNG_SPRITE_H_

#include "flatbuffers/flatbuffers.h"

namespace dung {
namespace sprite {

struct SpriPart;

struct ActionPacket;

MANUALLY_ALIGNED_STRUCT(4) ActionPacket FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t action_code_;
  int16_t action_lock_;
  int32_t start_x_;
  int32_t start_y_;
  int8_t frame_number_;
  int8_t padding0__;
  int16_t animation_speed_;

 public:
  ActionPacket() {
    memset(this, 0, sizeof(ActionPacket));
  }
  ActionPacket(const ActionPacket &_o) {
    memcpy(this, &_o, sizeof(ActionPacket));
  }
  ActionPacket(int16_t _action_code, int16_t _action_lock, int32_t _start_x, int32_t _start_y, int8_t _frame_number, int16_t _animation_speed)
      : action_code_(flatbuffers::EndianScalar(_action_code)),
        action_lock_(flatbuffers::EndianScalar(_action_lock)),
        start_x_(flatbuffers::EndianScalar(_start_x)),
        start_y_(flatbuffers::EndianScalar(_start_y)),
        frame_number_(flatbuffers::EndianScalar(_frame_number)),
        padding0__(0),
        animation_speed_(flatbuffers::EndianScalar(_animation_speed)) {
    (void)padding0__;
  }
  int16_t action_code() const {
    return flatbuffers::EndianScalar(action_code_);
  }
  int16_t action_lock() const {
    return flatbuffers::EndianScalar(action_lock_);
  }
  int32_t start_x() const {
    return flatbuffers::EndianScalar(start_x_);
  }
  int32_t start_y() const {
    return flatbuffers::EndianScalar(start_y_);
  }
  int8_t frame_number() const {
    return flatbuffers::EndianScalar(frame_number_);
  }
  int16_t animation_speed() const {
    return flatbuffers::EndianScalar(animation_speed_);
  }
};
STRUCT_END(ActionPacket, 16);

struct SpriPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_PART_CODE = 6,
    VT_TILE_SIZE = 8,
    VT_ACTIONS = 10,
    VT_IMG_CODE = 12,
    VT_HEALTH_CONTRA = 14,
    VT_ARMOUR_CONTRA = 16,
    VT_DAMAGE_CONTRA = 18,
    VT_MAGIC_CONTRA = 20,
    VT_MOVEMENT_CONTRA = 22,
    VT_SPRINT_CONTRA = 24,
    VT_JUMP_CONTRA = 26,
    VT_EVIL_CONTRA = 28,
    VT_RELATIVE_X = 30,
    VT_RELATIVE_Y = 32,
    VT_ABILITIES = 34
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  uint32_t part_code() const {
    return GetField<uint32_t>(VT_PART_CODE, 0);
  }
  int8_t tile_size() const {
    return GetField<int8_t>(VT_TILE_SIZE, 16);
  }
  const flatbuffers::Vector<const ActionPacket *> *actions() const {
    return GetPointer<const flatbuffers::Vector<const ActionPacket *> *>(VT_ACTIONS);
  }
  int16_t img_code() const {
    return GetField<int16_t>(VT_IMG_CODE, 1);
  }
  int32_t health_contra() const {
    return GetField<int32_t>(VT_HEALTH_CONTRA, 0);
  }
  int32_t armour_contra() const {
    return GetField<int32_t>(VT_ARMOUR_CONTRA, 0);
  }
  int32_t damage_contra() const {
    return GetField<int32_t>(VT_DAMAGE_CONTRA, 0);
  }
  int32_t magic_contra() const {
    return GetField<int32_t>(VT_MAGIC_CONTRA, 0);
  }
  int32_t movement_contra() const {
    return GetField<int32_t>(VT_MOVEMENT_CONTRA, 0);
  }
  int32_t sprint_contra() const {
    return GetField<int32_t>(VT_SPRINT_CONTRA, 0);
  }
  int32_t jump_contra() const {
    return GetField<int32_t>(VT_JUMP_CONTRA, 0);
  }
  int32_t evil_contra() const {
    return GetField<int32_t>(VT_EVIL_CONTRA, 0);
  }
  int32_t relative_x() const {
    return GetField<int32_t>(VT_RELATIVE_X, 0);
  }
  int32_t relative_y() const {
    return GetField<int32_t>(VT_RELATIVE_Y, 0);
  }
  const flatbuffers::Vector<uint32_t> *abilities() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<uint32_t>(verifier, VT_PART_CODE) &&
           VerifyField<int8_t>(verifier, VT_TILE_SIZE) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.Verify(actions()) &&
           VerifyField<int16_t>(verifier, VT_IMG_CODE) &&
           VerifyField<int32_t>(verifier, VT_HEALTH_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_ARMOUR_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_MAGIC_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_MOVEMENT_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_SPRINT_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_JUMP_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_EVIL_CONTRA) &&
           VerifyField<int32_t>(verifier, VT_RELATIVE_X) &&
           VerifyField<int32_t>(verifier, VT_RELATIVE_Y) &&
           VerifyOffset(verifier, VT_ABILITIES) &&
           verifier.Verify(abilities()) &&
           verifier.EndTable();
  }
};

struct SpriPartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(SpriPart::VT_PATH, path);
  }
  void add_part_code(uint32_t part_code) {
    fbb_.AddElement<uint32_t>(SpriPart::VT_PART_CODE, part_code, 0);
  }
  void add_tile_size(int8_t tile_size) {
    fbb_.AddElement<int8_t>(SpriPart::VT_TILE_SIZE, tile_size, 16);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<const ActionPacket *>> actions) {
    fbb_.AddOffset(SpriPart::VT_ACTIONS, actions);
  }
  void add_img_code(int16_t img_code) {
    fbb_.AddElement<int16_t>(SpriPart::VT_IMG_CODE, img_code, 1);
  }
  void add_health_contra(int32_t health_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_HEALTH_CONTRA, health_contra, 0);
  }
  void add_armour_contra(int32_t armour_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_ARMOUR_CONTRA, armour_contra, 0);
  }
  void add_damage_contra(int32_t damage_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_DAMAGE_CONTRA, damage_contra, 0);
  }
  void add_magic_contra(int32_t magic_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_MAGIC_CONTRA, magic_contra, 0);
  }
  void add_movement_contra(int32_t movement_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_MOVEMENT_CONTRA, movement_contra, 0);
  }
  void add_sprint_contra(int32_t sprint_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_SPRINT_CONTRA, sprint_contra, 0);
  }
  void add_jump_contra(int32_t jump_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_JUMP_CONTRA, jump_contra, 0);
  }
  void add_evil_contra(int32_t evil_contra) {
    fbb_.AddElement<int32_t>(SpriPart::VT_EVIL_CONTRA, evil_contra, 0);
  }
  void add_relative_x(int32_t relative_x) {
    fbb_.AddElement<int32_t>(SpriPart::VT_RELATIVE_X, relative_x, 0);
  }
  void add_relative_y(int32_t relative_y) {
    fbb_.AddElement<int32_t>(SpriPart::VT_RELATIVE_Y, relative_y, 0);
  }
  void add_abilities(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> abilities) {
    fbb_.AddOffset(SpriPart::VT_ABILITIES, abilities);
  }
  SpriPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpriPartBuilder &operator=(const SpriPartBuilder &);
  flatbuffers::Offset<SpriPart> Finish() {
    const auto end = fbb_.EndTable(start_, 16);
    auto o = flatbuffers::Offset<SpriPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpriPart> CreateSpriPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint32_t part_code = 0,
    int8_t tile_size = 16,
    flatbuffers::Offset<flatbuffers::Vector<const ActionPacket *>> actions = 0,
    int16_t img_code = 1,
    int32_t health_contra = 0,
    int32_t armour_contra = 0,
    int32_t damage_contra = 0,
    int32_t magic_contra = 0,
    int32_t movement_contra = 0,
    int32_t sprint_contra = 0,
    int32_t jump_contra = 0,
    int32_t evil_contra = 0,
    int32_t relative_x = 0,
    int32_t relative_y = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> abilities = 0) {
  SpriPartBuilder builder_(_fbb);
  builder_.add_abilities(abilities);
  builder_.add_relative_y(relative_y);
  builder_.add_relative_x(relative_x);
  builder_.add_evil_contra(evil_contra);
  builder_.add_jump_contra(jump_contra);
  builder_.add_sprint_contra(sprint_contra);
  builder_.add_movement_contra(movement_contra);
  builder_.add_magic_contra(magic_contra);
  builder_.add_damage_contra(damage_contra);
  builder_.add_armour_contra(armour_contra);
  builder_.add_health_contra(health_contra);
  builder_.add_actions(actions);
  builder_.add_part_code(part_code);
  builder_.add_path(path);
  builder_.add_img_code(img_code);
  builder_.add_tile_size(tile_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriPart> CreateSpriPartDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    uint32_t part_code = 0,
    int8_t tile_size = 16,
    const std::vector<const ActionPacket *> *actions = nullptr,
    int16_t img_code = 1,
    int32_t health_contra = 0,
    int32_t armour_contra = 0,
    int32_t damage_contra = 0,
    int32_t magic_contra = 0,
    int32_t movement_contra = 0,
    int32_t sprint_contra = 0,
    int32_t jump_contra = 0,
    int32_t evil_contra = 0,
    int32_t relative_x = 0,
    int32_t relative_y = 0,
    const std::vector<uint32_t> *abilities = nullptr) {
  return dung::sprite::CreateSpriPart(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      part_code,
      tile_size,
      actions ? _fbb.CreateVector<const ActionPacket *>(*actions) : 0,
      img_code,
      health_contra,
      armour_contra,
      damage_contra,
      magic_contra,
      movement_contra,
      sprint_contra,
      jump_contra,
      evil_contra,
      relative_x,
      relative_y,
      abilities ? _fbb.CreateVector<uint32_t>(*abilities) : 0);
}

inline const dung::sprite::SpriPart *GetSpriPart(const void *buf) {
  return flatbuffers::GetRoot<dung::sprite::SpriPart>(buf);
}

inline bool VerifySpriPartBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<dung::sprite::SpriPart>(nullptr);
}

inline void FinishSpriPartBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dung::sprite::SpriPart> root) {
  fbb.Finish(root);
}

}  // namespace sprite
}  // namespace dung

#endif  // FLATBUFFERS_GENERATED_SPRITE_DUNG_SPRITE_H_
